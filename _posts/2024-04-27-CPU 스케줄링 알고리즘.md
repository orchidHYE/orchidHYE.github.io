---
layout: post
title: "[운영체제] CPU 스케줄링 알고리즘"
date: 2024-04-27 23:33 +0900
categories:
  - CS
  - OS
tags: 
math: true
---
##  CPU 스케줄링
- 운영체제가 프로세스들에게 공정하고 합리적으로 CPU 자원을 배분하는 것

## 프로세스 우선순위
![](https://i.imgur.com/13xVIfI.png)
CPU 작업이 많은 프로세스보다 입출력 작업이 많은 프로세스의 우선순위가 더 높다


#### 스케줄링 큐
 - **프로세스 보관**
	 - 준비 상태(ready)의 프로세스를 보관하는 공간.
	 - CPU를 할당받을 차례를 기다리는 프로세스들이 대기
- **프로세스 스케줄링 순서 결정**
	- 스케줄링 알고리즘에 다라 준비 상태 프로세스의 실행 순서 결정
	- 예를 들어, 선입선출 (FIFO), 최소 잔여 시간 (SRT), 라운드 로빈 (RR) 등의 알고리즘 활용
- **프로세스 상태 전이 관리**
	- 프로세스가 실행 상태에서 대기 상태로, 대기 상태에서 실행 상태로 전이할 때 스케줄링 큐 활용

>###### (스케줄링 큐를 적용한) 프로세스 상태 다이어그램
>![](https://i.imgur.com/TNnSe2K.png)

<br/>

#### 선점형 스케줄링 (preemptive scheduling)
![](https://i.imgur.com/gVkY7jV.png)
- 현재 CPU를 사용 중인 프로세스로부터 CPU 자원을 빼앗아 다른 프로세스에 할당

###### 선점형 스케줄링의 장점
- 한 프로세스의 자원 독점을 막고 프로세서들에 골고루 자원을 배분할 수 있다.
###### 선점형 스케줄링의 단점
- 문맥 교환 과정에서 오버헤드가 발생할 수 있다.

#### 비선점형 스케줄
![](https://i.imgur.com/jlVwuXC.png)
- 현재 CPU를 사용 중인 프로세스의 작업이 끝날 때까지 프로세스 기다리기

###### 비선점형 스케줄링의 장점
- 선점형 스케줄링에 비해 문맥 교환에서 발생하는 오버헤드가 적다.

###### 비선점형 스케줄링의 단점
- 모든 프로세스가 골고루 자원을 이용하기 어렵다.

## 알고리즘
## 선입 선처리 스케줄링 (First Come First Served)
- 단순히 준비 큐에 삽입된 순서대로 처리하는 비선점 스케줄링
- 먼저 CPU를 요청한 프로세스부터 CPU 할당

#### 단점
- 호위 효과를 야기할 수도 있다.
	- 프로세스들이 기다리는 시간이 매우 길어질 수 있다는 것

###### 호위 효과를 방지하려면?
## 최단 작업 우선 스케줄링 (Shortest Job First)
- CPU **사용 시간이 가장 짧은 프로세스부터 처리**하는 스케줄링 방식
- CPU 사용이 긴 프로세스는 나중에 실행, CPU 사용 시간이 짧은 프로세스는 먼저 실행

## 라운드 로빈 스케줄링 (Round Robin)
![](https://i.imgur.com/NkNLxzh.png)
- 선입 선처리 스케줄링 + 타임 슬라이스 (time slice)
	- 타임 슬라이스: 각 프로세스가 CPU를 사용할 수 있는 정해진 시간
- 정해진 타임 슬라이스만큼의 시간 동안 돌아가며 CPU를 이용하는 선점형 스케줄링
`* 타임 슬라이스의 크기가 중요하다. 타임 슬라이스의 크기가 크면 선입 선처리 스케줄링의 단점인 호위 효과를 겪을 수 있기 때문이다.`
`* 반대로 타임 슬라이스의 크기가 너무 작아도 문제다. 문맥 교환이 발생하는 오버헤드로 CPU의 부담이 커질수도 있기 때문이다. `


## 최소 잔여 시간 우선 스케줄링 (Shortest Remaining Time)
- 최단 작업 우선 스케줄링 + 라운드 로빈 스케줄링
- 정해진 시간만큼 CPU를 이용하되, 다음으로 CPU를 사용할 프로세스로는 남은 작업 시간이 가장 적은 프로세스 선택

## 우선순위 스케줄링
- 프로세스들에 우선순위를 부여하고, 우선순위 높은 프로세스부터 실행
- 우선순위가 같은 프로세스들은 선입 선처리로 스케줄링
- 최단 작업 우선 스케줄링, 최소 잔여 시간 스케줄링은 우선순위 스케줄링에 포함된다.

#### 단점
![](https://i.imgur.com/r2IgErY.png)
###### 기아(starvation) 현상
- 우선순위 높은 프로세스만 실행되는 현상
- 우선순위 낮은 프로세스가 준비 큐에 먼저 삽입되었음에도 불구하고 실행 연기

#### 기아 현상을 해결하기 위한 `에이징(aging)` 기법
![](https://i.imgur.com/wGW8krB.png)
- 오랫동안 대한 프로세스의 우선순위를 점차 높이는 방식
- 대기 중인 프로세스의 우선순위를 마치 나이 먹듯 점차 증가시키는 방식

## 다단계 큐 스케줄링 (Multilevel queue) 
![](https://i.imgur.com/n1ZUZ9D.png)
- 우선순위 스케줄링의 발전된 형태
- 우선순위별로 준비 큐를 여러 개 사용하는 스케줄링 방식
	- 우선순위가 가장 높은 큐에 있는 프로세스를 먼저 처리
	- 우선순위가 가장 높은 큐가 비어 있으면 그 다음 우선순위 큐에 있는 프로세스 처리

>※ 프로세스를 유형별로 처리할 수 있다는 장점이 있다.

<br/>

#### 단점
- 큐 간의 이동이 불가하다는 단점이 있다.
- 이 말은 즉, 우선순위가 낮은 프로세스는 계속해서 실행이 연기 될 수 있고 이로인해 기아 현상이 발생할 수도 있다는 것이다.

###### 위와 같은 다단계 큐의 단점을 보완해주는

## 다단계 피드백 큐 스케줄링 (Multilevel feedback queue)
![](https://i.imgur.com/lu5JOrY.png)

- 프로세스의 CPU 시간이 길면 우선순위가 낮아지고, 또 다른 프로세스가 낮은 우선순위 큐에서 오래 기다리면 우선순위를 높이는 방
- 다단계 큐 스케줄링의 발전된 형태
- 큐 간의 이동이 가능한 다단계 큐 스케줄링

>![](https://i.imgur.com/N4lVBnj.png)
>- CPU 집중 프로세스의 우선순위는 상대적으로 낮아지고
>- 입출력 집중 프로세스의 우선순위는 상대적으로 높아진다.


