---
layout: post
title: "[컴퓨터 구조] 보조기억장치"
date: 2024-04-17 20:12 +0900
categories:
  - CS
  - Architecture
tags: 
math: true
---
## **보조기억장치**
## **하드 디스크**
- 자기적인 방식으로 데이터 저장
#### 하드 디스크 구성
![](https://i.imgur.com/WGOE9Rr.jpeg)
- 일반적으로 플래터 양면 모두 사용
- RPM (Revolution Per Minute): 분당 회전수


![](https://i.imgur.com/O0wDpcq.jpeg)
- 일반적으로 모든 헤드가 디스크 암에 부착되어 함께 이동

#### **하드디스크 저장 단위**
![](https://i.imgur.com/XUqpirt.jpeg)
- 기본적으로 **트랙(track)**과 **섹터(sector)단위로 데이터 저장**
- 섹터의 크기: 512바이트 ~ 4906바이트

> ##### **실린더 (cylinder)**
>![](https://i.imgur.com/3Ki2FWJ.jpeg)
>- 여러 겹의 플래터 상에서 갗은 트랙이 위치한 곳을 모아 연결한 논리적 단위
>- 플래터는 트랙과 섹터로 나뉘고, 같은 트랙이 모여 **실린더**를 이룬다.

<br/>

![](https://i.imgur.com/QR1JTqg.jpeg)

- 연속된 정보는 한 실린더에 기록

## **하드 디스크 데이터 접근 과정**
- 하드 디스크가 저장된 데이터에 접근하는 시간간
	- 탐색 시간 (seek time)
	- 회전 지연 (rotainal latency)
	- 전송 시간 (transfer time)

#### **탐색 시간**
![](https://i.imgur.com/6pckuCE.jpeg)
- 접근하려는 데이터가  저장된 트랙까지 헤드를 이동세키는 시간

#### **회전 지연**
![](https://i.imgur.com/juI64sy.jpeg)
- 헤드가 있는 곳으로 플레터를 회전시키는 시간

#### **전송 시간**
![](https://i.imgur.com/o8nZQxc.jpeg)
- 하드 디스크와 컴퓨터 간에 데이터를 전송하는 시간


> ##### **Jeff Dean의 Numbers Every Programmer Should Know 중**
앞서 숙지한 바와 같이 메모리를 참조하는 것보다 L2캐시를 참조하는 시간이 더 빠르고, L2캐시를 참조하는 것보다 L1캐시를 참조하는 시간이 더 빠르다.
또, 캐시와 메모리의 시간차가 크게 나는 것을 확인할 수 있다.

<br/>

## **플래시 메모리**

![](https://i.imgur.com/jgwA4zi.jpeg)

- 전기적으로 데이터를 읽고 쓰는 반도체 기반 저장 장치<br/>
`* 범용성이 넓기에 보조기억장치에만 속한다고 보기는 어렵다.`

<br/>

> ##### **플래시 메모리의 종류**
>- NAND 플래시 메모리
>- NOR 플래시 메모리
>
범용적으로 사용되는 NAND 플래시 메모리에 대해 학습한다.

## **셀 (cell)**
- 플래시 메모리에서 데이터를 저장하는 가장 작은 단위
- 이 셀이 모이고 모여 MB, GB, TB 저장 장치가 된다.
#### **SLC**
- 한 셀로 두 개의 전보 표현
- 비트의 빠른 입출력
- 긴 수명
- 용령 대비 고가격

#### **MLC**
- 한 셀로 네 개의 정보 표현 (대용량화 유리)
- SLC보다 느린 입출력
- SLC보다 짧은 수명
- SLC보다 저렴
- 시중에서 많이 사용 (MLC, TLC, QLC)

#### **TLC**
- 한 셀로 여덟 개의 정보 표현 (대용량화 유리)
- MLC보다 느린 입출력
- MLC보다 짧은 수명
- MLC보다 저렴
- 시중에서 많이 사용 (MLC, TLC, QLC)

**같은 플래시 메모리라도 수명, 가격, 성능이 다르다는 것**

<br/>


>![](https://i.imgur.com/dWfTfrK.jpeg)
>- 셀이 모여 페이지 (page)
>- 페이지가 모여 블록 (block)
>- 블록이 모여 플레인 (plane)
>- 플레인이 모여 다이 (die)



>- 읽기/쓰기 단위와 삭제 단위는 다르다
>	- 읽기/쓰기는 페이지 단위
>	- 삭제는 (페이지보다 큰) 블록 단위로 이루어짐

<br/>

## 페이지의 상태
#### Free 상태
- 어떠한 데이터도 저장하고 있지 않아 새로운 데이터을 저장할 수 있는 상태
#### Valid 상태
- 이미 유효한 데이터를 저장하고 있는 상태
#### Invalid 상태
- 유효하지 않은 데이터(쓰레기값)를 저장하고 있는 상태<br/>
`* 플래시 메모리는 하드 디스크와 달리 덮어쓰기 불가능`

<br/>

> ##### **플래시 메모리의 동작 예시**
>![](https://i.imgur.com/6M6ankf.jpeg)
>- A와 B페이지로 인해 블록 X가 존재한다.
>![](https://i.imgur.com/iXVEkZO.jpeg)
>- C라는 데이터를 저장한다고 가정해보자.<br/>
>
>- C는 블록 X의 Free 상태인 곳에 저장 될 것이다.
>- 새롭게 저장된 C와 기존에 저장되어 있던 B는 **그대로 둔 채** 기존의 A만을 A'로 수정해보자.<br/>
>
**여기서 문제는 위에서 설명됐듯, 삭제는 블록 단위로만 가능하기 때문에 A만을 수정할 수는 없다.**<br/><br/>
어떤 방법이 있느냐.
>- A를 Invalid 상태로 변경 후, Free 상태인 곳에 A'를 새롭게 저장한다.
>- 즉, Valid 상태인 것은 B, C, A' 뿐이고 A는 쓰레기 값이 된다.
>
하지만 이렇게 끝나게 되면 A와 같은 쓰레기 값은 **불필요한 용량을 차지하는 것**이된다.<br/>
이 문제를 해결해 줄 `가비지 컬렉션`이 있다.<br/><br/>
가비지 컬렉션이란,
>1. 유효한 페이지만을 새로운 블록으로 복사
>2. 기존의 블록을 삭제
>
>![](https://i.imgur.com/7nwEG3L.jpeg)
>위와 같은 방식으로 **공간을 정리하는 기능**이다.<br/>
가비지 컬렉션 기능이 작동되어 Invalid 상태였던 페이지을 Free 상태로 정리하여 새로운 값을 또 저장할 수 있는 상태가 되었다.

<br/>

## **RAID (Redundant Array of Independent Disks)**
- 하드 디스크와 SSD로 사용하는 기술
- 데이터의 안정성 혹은 높은 성능을 위해 **여러 물리적 보조기억장치를** 마치 **하나의 논리적 보조기억장치처럼 사용**하는 기술
- 1TB 하드 디스크 네 개로 RAID를 구성하여 사용하는 것은, 4TB 하드 디스크 한 개를 사용하는 것보다 성능과 안전성이 능가할 수 있다.

## **RAID 레벨 (종류)**
- RAID를 구성하는 기술
- RAID 0, RAID 1, RAID 2, RAID 3, RAID4, ...
	- 파생된 RAID 10, RAID 50, ...

#### **RAID 0**
- 데이터를 단순히 나누어 저장하는 구성 방식

<br/>

>![](https://i.imgur.com/l02REFg.png)
>-  1TB 하드 디스크 네 개가 있다고 가정.
>![](https://i.imgur.com/pPUFwoU.png)
>- 각 하드 디스크에 번갈아 가며 데이터가 저장된다.
>- 저장되는 데이터가 하드 디스크 개수만큼 나뉘어 저장된다.<br/><br/>
`* stripe: 줄무늬처럼 분산되어 저장된 데이터`<br/>
`* striping: 분산하여 저장하는 것`


##### **RAID 0 장점**
![](https://i.imgur.com/cBLb1mt.png)
- **입출력 속도의 향상**
- 위와 같이 하드 디스크가 분산되어 구성되어있지 않았더라면,<br/>하드 디크스 1에서 저장된 데이터를 세로 방향, 즉 순차적으로 데이터를 전송해야만 했을 것이다. <br/>하지만 RAID 0은 순차적으로 데이터를 전송하지 않아도 되기 때문에 입출력 속도가 빠르다는 것이다.

##### **RAID 0 단점**
![](https://i.imgur.com/8MxyyJ0.png)

- **저장된 정보가 안전하지 않음**
- 데이터를 나누어 저장하였기 때문에 하드 디스크가 고장난다면 데이터 손실이 우려될 수 있다.

#### **RAID 1**
- 미러링(mirroring)
- 복사본을 만드는 방식
- 데이터를 쓸 때 원본과 복사본 두 군데에 씀 (느린 쓰기 속도)

![](https://i.imgur.com/QujBToX.png)


##### **RAID 1 장점**
- 백업과 복구 용이 (RAID 0과 대조)

##### **RAID 1 단점**
- 입출력시 원본, 복사본에 작업이 진행되기에 느리다.
- 하드 디스크 개수가 한정되었을 때 사용 가능한 용량이 적어지진다.<br/>
`복사본이 만들어지는 용량만큼 사용 불가 → 많은 양의 하드 디스크 필요 → 비용 증가`<br/>

#### **RAID 4**
- RAID 1과 같이 완전한 복사본을 만드는 대신, 패리티 비트를저장
- 패리티를 저장한 장치를 이용해 다른 장치들의 오류를 검출하고, 오류가 있다면 복구
![](https://i.imgur.com/gdEEq8C.png)

`* 패리티 비트: 오류를 검출하고 복구하기 위한 정보`<br/>
`* 컴퓨터 공학의 정의로는 오류 검출만 가능할 뿐 복구는 불가능 하다고 한다.`
<br/>

##### **RAID 4 단점**
![](https://i.imgur.com/DZN4XAM.png)
- 패리티 디스크의 병목 현상 발생 가능성
- 새로운 입력이 있을 때마다, 패리티 디스크에도 저장이 되어야 하기 때문에 패리티 정보가 한 곳에 몰려있다면 병목 현상이 생길 수도 있다.
- 이와 같은 단점을 보완하기 위한 RAID 5가 생김.


#### **RAID 5**
- 패리티 정보를 분산하여 저장하는 방식
- RAID 4의 단점이였던 병목 현상이 완화된다는 것이 특징
![](https://i.imgur.com/ReE1nYQ.png)


#### **RAID 6**
- 두 종류의 패리티 (오류를 검출하고 복구할 수 있는 수단)
![](https://i.imgur.com/qLDfOeL.png)


##### **RAID 6 장점**
- RAID 5보다 안전

##### **RAID 6 단점**
- 두 종류의 패리티 비트를 저장하여야 하기 때문에 RAID 5보다 쓰기 성능이 느림 

<br/><br/>

>###### 컴퓨터 구성 시 RAID 설정 화면
>![](https://i.imgur.com/2LF9NmJ.png)
>![](https://i.imgur.com/HgUP3kx.png)
이미지 출처: [ASUS](https://www.asus.com/kr/support/faq/1045089/){:style="text-decoration: none; color: black;"}


<br/><br/>

`* 각 RAID 레벨마다 장단점이 존재하기 때문에, 어떤 상황에서 무엇을 최우선으로 하는지에 따라 최적의 RAID 레벨은 달라질 수 있다.`<br/><br/>
`* 안전하고 높은 성능을 내는 방식에 RAID만 있는 것은 아니다.`