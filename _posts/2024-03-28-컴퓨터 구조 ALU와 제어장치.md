# **ALU**
- CPU 내에 있는 회로이며 연산을 수행한다.
- 제어 장치로부터 명령을 받아 연산을 수행한다.

1. **산술 연산 수행**
	1. 덧셈, 뺄셈, 곱셈, 나눗셈 등의 기본 산술 연산 수행
2. **비트 연산 수행**
	1. AND, OR, NOT, XOR 등의 비트 단위 논리 연산 수행
	2. 이러한 비트 연산은 프로그램의 조건문, 루프 등을 처리하는데 사용된다.
3. **쉬프트 연산 수행**
	1. 데이터를 왼쪽이나 오른쪽으로 비트 단위로 이동시키는 쉬프트 연산 수행
4. **비교 연산 수행**
	1. 두 값을 비교하여 동일한지, 큰지, 작은지 등을 판별하는 비교 연산을 수행

## **ALU가 받아들이는 정보**
- 계산을 하기 위해서는 **피연산자**와 **수행할 연산**이 필요하다.
- **피연산자는 레지스터로부터** 받아들이고, **제어장치로부터 제어 신호**를 받아들인다.

## **ALU가 내보내는 정보**
- **받아들인 정보의 결과값**을 또 다른 레지스터에 저장한다.
 > **결과값을 메모리가 아닌, 레지스터에 저장하는 이유** <br/>
> CPU가 메모리에 접근하는 것보다 레지스터에 접근하는 것이 더 **빠르기 때문**이다.
- **플래그**
	- **연산 결과에 대한 부가 정보** (양수 || 음수 판단 등)
	- 이 부가 정보, 즉 플래그 값은 `플래그 레지스터`에 저장된다.
	- 연산 결과가 레지스터에 비해 커서 담을 수 없을 때, 플래그 레지스터에 저장하며 이를 `오버플로우` 가 발생했다고 표현한다.


## **플래그 종류**

| 플래그 종류    | 의미                                   | 사용 예시                                                           |
| --------- | ------------------------------------ | --------------------------------------------------------------- |
| 부호 플래그    | 연산한 결과의 부호를 나타낸다.                    | 부호 플래그가 1일 경우 계산 결과는 음수, 0일 경우 계산 결과는 양수를 의미한다.                 |
| 제로 플래그    | 연산 결과가 0인지 여부를 나타낸다.                 | 제로 플래그가 1일 경우 연산 결과는0, 0일 경우 연산 결과는 0이 아님을 의미한다.                |
| 캐리 플래그    | 연산 결과 올림수나 빌림수가 발생했는지를 나타낸다.         | 캐리 플래그가 1일 경우 올림수나 빌림수가 발생했음을 의미하고, 0일 경우 발생하지 않았음을 의미한다.       |
| 오버플로우 플래그 | 오버플로우가 발생했는지를 나타낸다.                  | 오버플로우 플래그가 1일 경우 오버플로우가 발생했음을 의미하고, 0일 경우 발생하지 않았음을 의미한다.       |
| 인터럽트 플래그  | 인터럽트가 가능한지를 나타낸다.                    | 인터럽트 플래그가 1일 경우 인터럽트가 가능함을 의미하고, 0일 경우 인터럽트가 불가능함을 의미한다.        |
| 슈퍼바이저 플래그 | 커널 모드로 실행 중인지, 사용자 모드로 실행 중인지를 나타낸다. | 슈퍼바이저 플래그가 1일 경우 커널 모드로 실행 중임을 의미하고, 0일 경우 사용자 모드로 실행 중임을 의미한다. |




# **제어장치**
- 제어 장치는 CPU의 '두뇌' 역할을 한다.
- 제어 신호를 통해 ALU에 적절한 연산을 지시하고, ALU는 해당 연산을 실행한 후 결과를 다시 제어 장치에 반환한다.


## **제어장치가 받아들이는 정보**
 - 클럭신호
	 - 일정한 주기를 가진 **펄스 형태**의 전기 신호
		![](https://i.imgur.com/nNsp6ym.png)
	- CPU 동작을 동기화하고 명령어 실행의 타이밍을 제어하는 신호
- `명령어 레지스터`로부터 받아들인 명령어
- `플래그 레지스터`로부터 받아들이는 플래그 값
- 제어 신호


## **제어장치가 내보내는 정보**
#### **제어신호**
- CPU 내부
	- ALU 제어 신호
		- ALU에 특정 연산을 수행하라고 지시하는 신호
		- ALU의 연산 모드를 설정하고 입력 값을 선택
	- 레지스터 제어 신호
		- 레지스터에 데이터를 적재/저장 하라는 신호
		- 레지스터 간 데이터 이동 경로 설정
- CPU 외부
	- 메모리 제어 신호
		- 메모리에 데이터를 읽거나 쓰라고 지시하는 신호
		- 메모리 주소 선택 및 메모리 액세스 타이밍 제어
	- 입출력 제어 신호
		- 외부 입출력 장치와의 데이터 전송을 제어하는 신호
		- 입출력 장치 선택, 데이터 전송 모드 설정 등을 수행




# **레지스터**
- CPU 내부의 작은 임시저장장치
- 프로그램 속 명령어 & 데이터는 실행 전후로 레지스터에 저장
- CPU 내부에는 다양한 레지스터들이 있고, 각기 다른 역할을 가진다.

## **레지스터 종류**

| 레지스터 종류     | 설명                                                                   |
| ----------- | -------------------------------------------------------------------- |
| 프로그램 카운터    | 다음에 실행할 명령어의 메모리 주소를 가리키는 레지스터                                       |
| 명령어 레지스터    | CPU가 메모리로부터 가져온 명령어를 일시적으로 저장하는 레지스터<br/>제어 장치가 이 레지스터의 명령어를 해독 후 실행 |
| 메모리 주소 레지스터 | 메모리에 접근할 때 사용하는 주소를 저장하는 레지스터<br/>메모리 주소 레지스터에 저장된 주소는 주소 버스를 통해 전달  |
| 메모리 버퍼 레지스터 | 메모리와 CPU 간의 데이터 전송 시 사용되는 임시 저장 공간 역할<br/>데이터 버스를 통해 데이터를 주고 받는다     |
| 플래그 레지스터    | CPU의 현재 상태를 나타내는 플래그 비트들을 저장하는 레지스터                                  |
| 범용 레지스터     | 프로그램 실행 중 다양한 목적으로 사용되는 범용 레지스터<br/>데이터 저장, 주소 저장, 인덱싱 등 다목적 활용      |
| 스택 포인터      | 현재 스택의 최상위 주소를 가리키는 레지스터, 스택 push/pop 연산 시 이 레지스터 값을 수정              |
| 베이스 레지스터    | 메모리 주소 계산 시 베이스 주소 역할을 하는 레지스터, 데이터 구조체 등에 접근할 때 유용                  |
`CPU 종류마다 레지스터 종류는 다르며, 똑같은 용도의 레지스터일지라도 CPU별 이름의 차이가 있을 수 있다.`

<br/>

#### 스택 포인터와 베이스 레지스터는 **주소 지정 방식에 사용되는 레지스터**이다.

#### **스택 포인터 - 스택 주소 지정 방식**
- 스택과 스택 포인터를 이용한 주소 지정 방식
- PUSH 연산
	- SP 레지스터 값을 감소시킨 후, 해당 주소에 데이터를 저장
	- 예를들어, PUSH EAX → EAX 레지스터 값을 스택에 푸시
- POP 연산
	- SP가 가리키는 주소에서 데이터를 읽은 후, SP 값을 증가 시킨다.
	- 예를들어, POP EBX → 스택에서 값을 꺼내 EBX에 저장
  

#### **베이스 레지스터 - 변위 주소 지정 방식**
- 오퍼랜드 필드의 값(변위)과 특정 레지스터의 값을 더하여 유효 주소를 얻는 방식
![](https://i.imgur.com/6MHA5mS.png)
- 위 설명 중 `특정 레지스터`는 프로그램 카운터가 될 수도, 베이스 레지스터가 될 수도 있다.

#### **상대 주소 지정 방식**
- 기본 주소로` 프로그램 카운`의 값을 사용
- **명령어에 포함된 변위 값을 프로그램 카운터 값에 더하여 실제 메모리 주소를 계산**
	![](https://i.imgur.com/nmRB86A.png)


#### **베이스 레지스터 주소 지정 방식**
- 기본 주소로 `베이스 레지스터`의 값을 사용
- **베이스 레지스터 값에 변위 값을 더하여 최종 메모리 주소를 계산**
	![](https://i.imgur.com/clpKshl.png)		 



> **프로그램이 순차적으로 실행되는 원리**
>1. 프로그램 카운터에 가져올 메모리 주소가 입력된다.<br/>
2. 메모리 주소 레지스터에 위에 입력된 주소가 입력된다. 이때, 주소 버스를 통해 메모리에 주소가 전달된다.<br/>
3. 메모리에 저장되어 있던 데이터 또는 명령어가 데이터 버스를 통해 메모리 버퍼 레지스터에 전달된다. 이때, **프로그램 카운터는 증가**한다.<br/>
프로그램이 순차적으로 실행될 수 있는 원리는 **프로그램 카운터가 순차적으로 증가**하기 때문이다. <br/><br/>
> **순차적인 실행 흐름이 끊기는 경우**
>* 특정 메모리 주소로 실행 흐름을 이동하는 명령어 실행 시 (예를들어, JUMP, CONDITIONAL JUMP, CALL, RET 등)
>* 인터럽트 발생 시 등
