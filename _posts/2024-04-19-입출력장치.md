---
layout: post
title: "[컴퓨터 구조] 입출력장치"
date: 2024-04-19 21:00 +0900
categories:
  - CS
  - Architecture
tags: 
math: true
---

`해당 게시글에는 보조기억장치를 입출력장치에 포함하여 설명한다.`<br/>
## **입출력장치**
##### **입출력장치는 앞서 학습한 CPU, 메모리보다 다루기가 더 까다롭다.**
- **입출력장치 종류의 다양화**
	- 장치가 다양하면 각각의 속도, 데이터 전송 형식 등도 다양하다.
	- 다양한 입출력장치와 정보를 주고받는 방식을 **규격화하기 어렵다.**
	- ![](https://i.imgur.com/H8UICV1.png)
- **CPU와 입출력장치의 전송률 차이**
	- 일반적으로 CPU와 메모리의 데이터 전송률은 높지만 입출력장치의 데이터 전송률은 낮다.



**위와 같은 이유로 입출력장치는 장치 컨트롤러를 통해 컴퓨터와 연결된다.**

## **장치 컨트롤러**
- 입출력장치가 컴퓨터 내부와 정보를 주고받을 수 있도록 하는 하드웨어

#### **장치 컨트롤러의 역할**
- CPU와 입출력장치 간의 통신중개
- 입출력장치의 오류 검출
- 데이터 버퍼링
	- `버퍼링:전송률이 높은 장치와 낮은 장치 사이에 주고받는 데이터를 버퍼라는 임시 저장 공간에 저장하여 전송률을 비슷하게 맞추는 방법`<br/>


#### **장치 컨트롤러의 구조**
![](https://i.imgur.com/6kPeJmK.png)
##### **데이터 레지스터**
- CPU와 입출력장치 사이에 주고받을 데이터가 담기는 레지스터 (버퍼)
- RAM을 사용하기도 한다.

##### **상태 레지스터**
- 상태 정보 저장
	- 입출력장치가 입출력 작업을 할 준비가 되었는지,
	- 입출력 작업이 완료되었는지,
	- 입출력장치에 오류는 없는지 등의 상태 정보

##### **제어 레지스터**
- 입출력장치가 수행할 내용에 대한 제어 정보


## **장치 드라이버**
 - 장치 컨트롤러의 동작을 감지하고 제어하는 프로그램
	 -  장치 컨트롤러가 입출력장치를 연결하기 위한 하드웨어적인 통로라면, **장치 드라이버**는 입출력장치를 연결하기 위한 **소프트웨어적인 통로**



>![](https://i.imgur.com/61sSPWb.png)
>- 장치 드라이버가 설치되어 있어야 CPU가 어떻게 동작 시키는지를 읽는다. 
>- 운영체제가 연결된 장치와 드라이버를 인식하고 실행할 수 있다면 컴퓨터 내부와 정보를 주고받을 수 있고,
>- 반대로 운영체제가 장치 드라이버를 인식하거나 실행할 수 없다면 그 장치는 컴퓨터 내부와 정보를 주고받을 수 없다.

<br/>

## 입출력 방식
#### 프로그램 입출력
- 프로그램 속 명령어로 입출력장치를 제어하는 방법
- 입출력 명령어로써 장치 컨트롤러와 상호작용


> ###### **프로그램 입출력 방식**
> <메모리에 저장된 정보를 하드 디스크에 백업>
> 1. CPU는 하드 디스크 컨트롤러의 **제어 레지스터**에 **쓰기** 명령 내보내기
> ![](https://i.imgur.com/gdwTkgD.png)
> 2. 하드 디스크 컨트롤러는 하드 디스크 상태 확인 → 상태 레지스터에 **준비 완료** 표시
>![](https://i.imgur.com/8ILqUPz.png)
>3. 1) CPU는 **상태 레지스터를 주기적으로 읽어보며** 하드 디스크의 준비 여부를 확인
>4. 2) 하드 디스크가 준비되었다면 백업할 메모리의 정보를 데이터 레지스터에 쓰기
>![](https://i.imgur.com/CBvYrWN.png)
>**CPU가 장치 컨트롤러의 레지스터 값을 읽고 쓰는 것이 프로그램 입출력 방식이다.**

##### 그렇다면 CPU가 장치 컨트롤러의 레지스터 값을 어떻게 아는 거일까?
- 메모리 맵 입출력
- 고립형 입출력

두 가지 방식이 있다.

##### 메모리 맵 입출력
![](https://i.imgur.com/7ATzwHa.png)
- **메모리**에 접근하기 위한 주소 공간과 **입출력장치**에 접근하기 위한 주소 공간을 하나의 주소 공간으로 간주하는 방법

##### 고립형 입출력
![](https://i.imgur.com/3HyF0PN.png)

- 메모리를 위한 주소 공간과 입출력 장치를 위한 주소 공간을 분리하는 방법
![](https://i.imgur.com/LGzJaFM.png)
- (입출력 읽기/쓰기 선을 활성화시키는) 입출력 전용 명령어 사용 


| 메모리 맵 입출력                | 고립형 입출력                  |
| ------------------------ | ------------------------ |
| 메모리와 입출력장치는 같은 주소 공간 사용  | 메모리와 입출력장치는 분리된 주소 공간 사용 |
| 메모리 주소 공간이 축소됨           | 메모리 주소 공간이 축소되지 않음       |
| 메모리와 입출력장치에 같은 명령어 사용 가능 | 입출력 전용 명령어 사용            |
 

#### 인터럽트 기반 입출력
![](https://i.imgur.com/SMwxlNA.png)
- 하드웨어 인터럽트는 **장치 컨트롤러에 의해 발생**

>###### 동시다발적인 인터럽트
<입출력장치가 많을 때를 가정해보자>
>![](https://i.imgur.com/RD3LLWs.png)
>###### 순차적으로 인터럽트 처리
>![](https://i.imgur.com/2hc7LXd.png)
>- 플래그 레지스터 속 인터럽트 비트를 비활성화한 채 인터럽트를 처리하는 경우<br/>
>`*NMI (Non-Maskable Interrupt): 인터럽트 비트를 비활성화해도 순차적으로 처리하는 것이 불가능하다. 이는 하드웨어의 고장, 정전 등 중요도가 높은 크리티컬 인터럽트 발생 경우에 해당한다.`<br/>
>###### 하지만, 현실적으로 모든 인터럽트를 순차적으로 처리할 수는 없다.
>###### 인터럽트 중에서도 **우선 순위가 높은 인터럽트**가 있다.
>###### 우선순위를 반영한 인터럽트
>![](https://i.imgur.com/QymkrI8.png)
>- NMI가 발생한 경우 혹은 플래그 레지스터 속 인터럽트 비트를 활성화한 채 인터럽트를 처리하는 경우 
>- 오른쪽 그림의 경우 우선순위가 높은 A를 실행중에, A보다 우선순위가 높은 B의 인터럽트 요청이 들어오면 실행중이던 A를 중단하고 B를 처리 후 다시 A를 실행한다.
>###### 우선순위를 반영한 인터럽트에는 **PIC(Programmable Interrupt controller)라는 하드웨어가 사용**된다.
>###### PIC(Programmable Interrupt controller)
>![](https://i.imgur.com/VRmhfK7.png)
>![](https://i.imgur.com/aoBxwue.png)
>1. 여러 장치 컨트롤러에 연결되어
>2. 장치 컨트롤러의 하드웨어 인터럽트의 우선순위를 판단한 뒤
>3. CPU에게 지금 처리해야 하는 인터럽트가 무엇인지 판단하는 하드웨어.<br/>
`* NMI 우선순위까지 판단하지는 않음`

<br/>

#### DMA 입출력 (Direct Memory Access)
![](https://i.imgur.com/Jifzw9V.png)
- CPU를 거치지 않고 입출력장치가 **메모리에 직접적으로 접근**하는 기능


>###### DMA 입출력 과정
>1. CPU는 DMA 컨트롤러에 입출력 작업을 명령
>![](https://i.imgur.com/WpwOLwk.png)
>2. DMA 컨트롤러는 CPU 대신 장치 컨트롤러와 상호작용하며 입출력 작업을 수행<sup style="color:red">*</sup>
>![](https://i.imgur.com/ISlLBRh.png)
>3. 입출력 작업이 끝나면 DMA 컨트롤러는 인터럽트를 통해 CPU에 작업이 끝났음을 알림
>![](https://i.imgur.com/7QvG9eQ.png)
><br/><br/>
>###### CPU는 입출력 작업의 시작과 끝만 관여
>`* 이때 DMA 컨트롤러는 필요한 경우 메모리에 직접 접근`

<br/>

##### 시스템 버스 == 공용 자원
- 때문에 **동시 사용 불가능**
	- CPU가 시스템 버스 사용시 DMA 컨트롤러는 시스템 버스 사용 불가
	- 반대로 DMA 컨트롤러가 시스템 버스 사용시 CPU는 시스템 버스 사용 불가

**그래서 DMA 컨트롤러는,**<br/>

![](https://i.imgur.com/qVjM5S9.png)

1. CPU가 시스템 버스를 이용하지 않을 때마다 조금씩 시스템 버스 이용
2. CPU가 일시적으로 시스템 버스를 이용하지 않도록 Request 요청 신호를 보낸 후 시스템 버스 이용

위와 같은 두 가지 방법으로 **Cycle stealing**을 진행한다.

## 입출력 버스
![](https://i.imgur.com/Dk3RHXH.png)
- 위와 같은 방식으로 다양한 장치 컨트롤러가 시스템 버스에 직접적으로 연결되어 있는 것은 좋지 않다.
- 시스템 버스를 불필요하게 두 번 이용해야 하기 때문이다.

![](https://i.imgur.com/mvNVIOT.png)

- 시스템 버스가 아닌, 입출력 버스에 연결한다.
- 입출력 버스를 통해 시스템 버스의 이용 빈도를 낮춘다.

#### 입출력 버스의 종류
![](https://i.imgur.com/13N77tw.png)
- PCI 버스
- PCI express (PCIe) 버스 등등