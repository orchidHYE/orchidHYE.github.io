---
layout: post
title: "[컴퓨터 구조] 명령어 사이클과 인터럽트"
date: 2024-03-30 23:51 +0900
categories:
  - CS
  - Architecture
tags: 
math: true
---
## **명령어 사이클과 인터럽트**
CPU는 정해진 흐름대로 명령어를 처리한다 이를 `명령어 사이클`이라한다.

이런 흐름을 끊는 것을 `인터럽트`라고 한다.

# 명령어 사이클
- CPU가 하나의 명령어를 실행하는 일련의 단계를 말한다.
- 이 과정을 통해 CPU는 명령어를 가져오고, 해석하고, 실행하며 결과를 저장한다.

#### 1. 인출 단계
- CPU의 제어 장치가 프로그램 카운터에 저장된 주소에서 명령어를 메모리로부터 가져온다.
- 가져온 명령어는 CPU 내부의 명령어 레지스터에 일시적으로 저장된다.

#### 2. 해석 단계
- 제어 장치가 명령어 레지스터에 저장된 명령어를 해독하고 분석한다.
- 해독된 명령어에 필요한 데이터의 주소를 계산하다.

#### 3. 실행 단계
- CPU의 연산 장치인 ALU가 해석된 명령어를 실제로 수행한다.
- 필요한 경우 메모리에서 데이터를 읽어오거나 메모리에 결과를 저장한다.

#### 4. 인터럽트 단계 (선택적)
- 입출력 장치 혹은 다른 하드웨어로부터 인터럽트 요청이 있을 경우 이 단계에서 처리된다.
- 현재 실행 중인 프로그램을 중단하고 인터럽트 서비스 루틴을 실행한다.

#### 5. 기록 단계
- 연산 결과를 메모리나 레지스터에 저장한다.
- 프로그램 카운터를 증가시켜 다음 명령어의 메모리 주소를 가리키게 한다.



#### CPU는 `인출 사이클`과 `실행 사이클`이 반복된다.

>**간접 주소 지정 방식**의 경우
>인출을 했다고 하더라도 바로 실행이 불가능한 경우가 있다.
>이럴때, **간접 사이클에 접근**하게 된다.
>![](https://i.imgur.com/aXoMEwJ.png)


#### 인터럽트 단계에 대해 더 자세히 알아보자.

## **인터럽트**
- interrupt 방해하다, 중단시키다
- CPU가 현재 실행 중인 프로그램을 일시적으로 중지하고 다른 작업을 수행해야 할 때 발생한다.
- 인터럽트 요청은 입출력 장치 혹은 타이머, 하드웨어 오류 등에 의해 발생할 수 있다.

#### **인터럽트 종류**
동기 인터럽트 (예외)
- 현재 실행 중인 프로그램의 명령에 의해 발생하는 인터럽트
- 예를들어, 잘못된 메무리 접근, 연산 오버플로우 등
- 폴트/트랩/중단/소프트웨어 인터럽트 등의 종류가 있다.

비동기 인터럽트 (하드웨어 인터럽트)
- 외부 하드웨어 장치나 이벤트에 의해 발생하는 인터럽트
- 예를들어, 키보드 입력, 타이머 인터럽트, 디스크 인터럽트 등
- **CPU가 입출력 작업 도중에도 효율적으로 명령어를 처리하기 위해** 하드웨어 인터럽트 사용
	- 입출력장치는 CPU에 비해 느리기 때문에 인터럽트가 없다면 CPU는 입출력장치의 실행완료 여부를 주기적으로 확인해야 한다는 단점이 발생.
	- 인터럽트가 존재하기에 입출력 작업 동안 CPU는 다른 작업을 할 수 있는 것이다. (비동기 인터럽트에 대한 설명을 읽고 `멀티쓰레드` 생각이 났다. `멀티쓰레드`와 비슷한 개념인건가? 하고 말이다.)


#### **하드웨어 인터럽트의 처리 순서**
#### 1. 인터럽트 요청
- 외부 하드웨어 장치 혹은 시스템 이벤트로부터 인터럽트 요청 발생 (키보드 입력, 타이머 인터럽트, 디스크 인터럽트 등)

`CPU는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부를 확인한다.`
#### 2. 현재 작업 중단
- CPU는 현재 실행 중인 프로그램 중단
- 레지스터 값, 플래그, 프로그램 카운터 등 현재 상태 보존

#### 3. 인터럽트 서비스 루틴 호출
- CPU는 인터럽트 백터 테이블에서 해당 인터럽트 유형에 대한 서비스 루틴의 주소 찾기
- 해당 주소로 분기하여 인터럽트 서비스 루틴 호출

#### 4. 인터럽트 서비스 루틴 실행
- 인터럽트 서비스 루틴이 실행되어 인터럽트 원인 처리

#### 5. 현재 상태 복원
- 인터럽트 서비스 루틴 실행 완료 후 CPU는 이전에 저장한 상태 복원
- 레지스터 값, 플래그, 프로그램 카운터 등을 원래 값으로 복원

#### 6. 인터럽트 처리 완료
- CPU는 인터럽트 처리 완료 후 이전에 중단된 프로그램 실행을 재개

`*인터럽트의 종류를 막론하고 인터럽트 처리 순서는 대동소이하다.`

- 인터럽트 요청 신호 
	- 외부 장치, 예외 상황에 의해 발생하는 하드웨어 신호
	- CPU에 인터럽트가 발생했음을 알려주는 역할
- 인터럽트 플래그
	- (앞선 글에서 나온 플래그 레지스터에 대한 설명 참고) CPU 내부의 레지스터 비트로, 인터럽트 가능 여부를 나타낸다.
	- 인터럽트 플래그가 활성화되어 있으면 CPU는 인터럽트 요청을 받아들일 수 있다.
	- 인터럽트 플래그를 비활성화하면 인터럽트 요청을 무시할 수 있다.
- 인터럽트 서비스 루틴
	- 인터럽트가 발생했을 때 실행되는 특수한 코드 블록
	- 인터럽트의 원인을 처리하고 필효한 작업 수행
	- 키보드 입력 처리, 타이머 업데이트, 디바이스 드라이버 실행 작업 등
	- 프로그램이기 때문에 메모리에 저장되어 있다.
- 인터럽트 백터
	- 인터럽트 백터 테이블은 메모리 영역으로, 각 인터럽트 유형에 대한 서비스 루틴의 시작 주소를 저장하고 있다.
	- CPU는 인터럽트가 발생하면 해당 인터럽트 유형의 백터 주소에서 서비스 루틴 주소를 읽어 온다.
	- 백터 테이블은 운영체제나 BIOS에 의해 초기화되고 관리된다.


>**모든 인터럽트를 인터럽트 플래그로 막을 수 있는 건 아니다.**<br/>
>비동기 인터럽트에는 인터럽트 플래그로 **막을 수 있는 인터럽트 (maskable interrupt)**와 **막을 수 없는 인터럽트(non maskable interrupt)**가 있다.<br/>
>대부분의 입출력장치 인터럽트는 막을 수 있고, 하드웨어 고장 혹은 정전과 같은 특수한 상황에서 막을 수 없는 인터럽트가 발생한다고 한다.

<br/>


![](https://i.imgur.com/5Bi8jof.png)
