---
layout: post
title: "[운영체제] 프로세스 상태와 계층 구조"
date: 2024-04-24 22:36 +0900
categories:
  - CS
  - OS
tags: 
math: true
---
## 프로세스 상태
#### 생성 상태
- 이제 막 메모리에 적재되어 PCB를 할당 받은 상태
- 준비가 완료되었다면 준비 상태로

#### 준비 상태
- 당장이라도 CPU를 할당 받아 실행할 수 있지만 자신의 차례가 아니기에 기다리는 상태
- 자신의 차례가 된다면 실행 상태로 (=디스패치)

#### 실행 상태
- CPU를 할당 받아 실행 중인 상태
- 할당된 시간 모두 사용 시(타이머 인터럽트 발생 시) 준비 상태로
- 실행 도중 입출력장치를 사용하면 입출력 작업이 끝날 때까지 대기 상태로

#### 대기 상태
- 프로세스가 실행 도중 입출력장치를 사용하는 경우
- 입출력 작업은 CPU에 비해 느리기에 이 경우 대기 상태로 접어듬
- 입출력 작업이 끝나면(입출력 완료 인터럽트를 받으면) 준비 상태로

#### 종료 상태
- 프로세스가 종료된 상태
- PCB, 프로세스의 메모리 영역 정리

*프로세스의 상태는 운영체제마다 조금씩 차이가 있다.

> ###### 프로세스 상태 다이어그램
>![](https://i.imgur.com/YtOaPtU.jpeg)

<br/>

## 프로세스 계층 구조
- 프로세스 실행 도중(시스템 호출을 통해) 다른 프로세스 생성 가능

#### 부모 프로세스
- 새 프로세스를 생성한 프로세스

#### 자식 프로세스
- 부모 프로세스에 의해 생성된 프로세스

###### 부모 프로세스와 자식 프로세스는 별개의 프로세스이므로 각기 다른 PID를 가진다.
###### 일부 운영체제에서는 자식 프로세스 PCB에 부모 프로세스 PID(PPID)를 명시하기도 한다.

> ###### 프로세스 계층 구조
>![](https://i.imgur.com/VLXSbe1.jpeg)
>- 자식 프로세스는 또 다른 자식 프로세스를 생성할 수 있으며 위와 같이 계층적인 구조를 형성한다. 
>###### 예시
>![](https://i.imgur.com/TSPpBxD.jpeg)
>1. 최초 프로세스 → 로그인 프로세스를 자식 프로세스로 생성
>2. 로그인 프로세스 → 사용자의 입력을 받을 수 있는(사용자 인터페이스) bash 프로세스를 자식 프로세스로 생성
>3. bash 프로세스 → Vim 프로세스를 자식 프로세스로 생성
>###### 그렇다면 최초의 프로세스는 무엇인가
>- 이는 명령어를 통해 확인할 수 있다.
>###### Linux
>![](https://i.imgur.com/xRQEF1U.png)
>###### macOS
>![](https://i.imgur.com/IpXfVoX.png)

<br/>

## 프로세스 생성 기법
> 부모 프로세스는 자식 프로세스를 어떻게 만들어 내고,<br/> 자식 프로세스는 어떻게 자신만의 코드를 실행할까

<br/>

#### 복제와 옷 갈아입기
- 부모 프로세스는 **fork 시스템 호출**을 통해 자신의 복사본을 자식 프로세스로 생성
- 자식 프로세스는 **exec 시스템 호출**을 통해 자신의 메모리 공간을 다른 프로그램으로 교체

> ###### fork 시스템 호출
>![](https://i.imgur.com/5VtETZZ.jpeg)
>- 복사본(=자식 프로세스) 생성
>- 부모 프로세스의 자원(메모리 내용, 열린 파일 목록과 같은 것들) 상속<br/>
>
`* 복제된 프로세스로 동일한 자원이지만, 부모 프로세스와 자식 프로세스는 별개의 프로세스이기 때문에 PID와 저장된 메모리 위치는 다르다.`
>###### exec 시스템 호출
>![](https://i.imgur.com/AuX3Pbh.jpeg)
>- 메모리 공간을 새로운 프로그램으로 덮어쓰기
>- 코드/데이터 영역은 시행할 프로그램 내용으로 바뀌고 나머지 영역은 초기화<br/>
>
`* exec 시스템 호출을 통해 부모 프로세스와 자식 프로세스는 서로 다른 프로그램을 병행 실행하게 된다. (fork 시스템 호출까지는 동일한 프로그램을 병행 실행하는 격이다.)`
